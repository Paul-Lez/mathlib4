/-
Copyright (c) 2024 Fangming Li. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Fangming Li, Jujian Zhang
-/
import Mathlib.Algebra.Polynomial.AlgebraMap
import Mathlib.Algebra.Polynomial.Div
import Mathlib.Algebra.Polynomial.Eval.SMul
import Mathlib.Data.Nat.Factorial.BigOperators
import Mathlib.RingTheory.PowerSeries.WellKnown

/-!
# Hilbert polynomials

In this file, we aim to formalise a useful fact: given any `p : ℤ[X]` and `d : ℕ`, there exists
some `h : ℚ[X]` such that for any large enough `n : ℕ`, `h(n)` is equal to the coefficient of `Xⁿ`
in the power series expansion of `p/(1 - X)ᵈ` (or `p * (PowerSeries.invOneSubPow ℤ d)`). This `h` is
unique and is called the Hilbert polynomial with respect to `p` and `d` (`Polynomial.hilbert p d`).

The above fact is used to construct the Hilbert polynomial of a graded module that satisfies certain
conditions. Specifically:
* Assume `A = ⊕ₙAₙ` is a Noetherian ring graded by `ℕ` such that `A` is generated by `a₁,...,aₛ` as
  an `A₀`-algebra, where for each `i = 1,...,s`, `aᵢ` is a homogeneous element in `A` of degree
  `dᵢ > 0`. Let `M = ⊕ₙMₙ` be a finitely generated `A`-module graded by `ℕ`. Then it is true that
  each `Mₙ` is a finitely generated module over `A₀`.
* Let `λ : C → ℤ` be an additive function, where `C` is the collection of all finitely generated
  `A₀`-modules; in other words, given any short exact sequence `0 ⟶ N ⟶ O ⟶ P ⟶ 0` of finitely
  generated modules over `A₀`, we have `λ(O) = λ(N) + λ(P)`. Then the Poincaré series of `M` in
  terms of `λ` is the formal power series `P(M, λ, X) = Σₙλ(Mₙ)Xⁿ`. The Hilbert-Serre Theorem states
  that `P(M, λ, X)` can be written as `p(X)/∏ᵢ₌₁,...,ₛ(1 - X ^ dᵢ)`, where `p(X)` is a polynomial
  with coefficients in `ℤ`.
* For the case when `d₁,...,dₛ = 1`, the Poincaré series of `M` with respect to `λ` can be expressed
  as `p(X)/(1 - X)ˢ`. Hence the fact stated in the beginning guarantees an `h : ℚ[X]` such that for
  any large enough `n : ℕ`, the coefficient of `Xⁿ` in `P(M, λ, X)` equals `h.eval (n : ℚ)`. This
  `h` is called the Hilbert polynomial of `M` in terms of `λ`, which is what we eventually want to
  formalise.
-/

open BigOperators Nat PowerSeries

namespace Polynomial

section greatestFactorOneSubNotDvd

variable {R : Type*} [CommRing R] (p : R[X]) (hp : p ≠ 0) (d : ℕ)

/--
Given a polynomial `p`, the factor `f` of `p` such that the product of `f` and
`(1 - X : R[X]) ^ p.rootMultiplicity 1` equals `p`. We define this here because if `p` is divisible
by `1 - X`, then the expression `p/(1 - X)ᵈ` can be reduced. We want to construct the Hilbert
polynomial based on the most reduced form of the fraction `p/(1 - X)ᵈ`. Later we will see that this
method of construction makes it much easier to calculate the specific degree of the Hilbert
polynomial.
-/
noncomputable def greatestFactorOneSubNotDvd : R[X] :=
  ((- 1 : R[X]) ^ p.rootMultiplicity 1) *
  (exists_eq_pow_rootMultiplicity_mul_and_not_dvd p hp 1).choose

local notation "gFOSND" => greatestFactorOneSubNotDvd

theorem pow_rootMultiplicity_mul_greatestFactorOneSubNotDvd_eq :
    ((1 - X : R[X]) ^ p.rootMultiplicity 1) * greatestFactorOneSubNotDvd p hp = p := by
  rw [greatestFactorOneSubNotDvd, ← mul_assoc, ← mul_pow]
  simp only [mul_neg, mul_one, neg_sub, map_one]
  exact id (exists_eq_pow_rootMultiplicity_mul_and_not_dvd p hp 1).choose_spec.1.symm

theorem greatestFactorOneSubNotDvd_ne_zero :
    greatestFactorOneSubNotDvd p hp ≠ 0 := fun h0 => by
  let hpow := pow_rootMultiplicity_mul_greatestFactorOneSubNotDvd_eq p hp
  rw [h0, mul_zero] at hpow; exact hp <| id hpow.symm

theorem natDegree_greatestFactorOneSubNotDvd_le [Nontrivial R] [NoZeroDivisors R] :
    (greatestFactorOneSubNotDvd p hp).natDegree ≤ p.natDegree := by
  have : p.natDegree = ((1 - X : R[X]) ^ p.rootMultiplicity 1 * gFOSND p hp).natDegree := by
    rw [pow_rootMultiplicity_mul_greatestFactorOneSubNotDvd_eq]
  rw [this, natDegree_mul]
  · exact (gFOSND p hp).natDegree.le_add_left (natDegree ((1 - X) ^ p.rootMultiplicity 1))
  · exact pow_ne_zero _ <| fun h0 => by
      let this : (1 - X : R[X]).coeff 0 = 0 := by rw [h0]; simp only [coeff_zero];
      simp only [coeff_sub, coeff_one_zero, coeff_X_zero, sub_zero, one_ne_zero] at this
  exact greatestFactorOneSubNotDvd_ne_zero p hp

theorem natDegree_pow_rootMultiplicity_sub_mul_greatestFactorOneSubNotDvd_le
    [Nontrivial R] [NoZeroDivisors R] (hp1 : d ≤ p.rootMultiplicity 1) :
    ((1 - X) ^ ((p.rootMultiplicity 1) - d) * greatestFactorOneSubNotDvd p hp).natDegree
    ≤ p.natDegree := by
  let this := pow_ne_zero (p.rootMultiplicity 1 - d) <| fun (h0 : (1 - X : R[X]) = 0) => by
    let this : (1 - X : R[X]).coeff 0 = 0 := by rw [h0, coeff_zero];
    simp only [coeff_sub, coeff_one_zero, coeff_X_zero, sub_zero, one_ne_zero] at this
  rw [show p.natDegree = ((((1 - X : R[X]) ^ (p.rootMultiplicity 1 - d + d))) *
    (gFOSND p hp)).natDegree by rw [← Nat.eq_add_of_sub_eq hp1 rfl,
    pow_rootMultiplicity_mul_greatestFactorOneSubNotDvd_eq], pow_add, mul_assoc,
    mul_comm ((1 - X) ^ d), ← mul_assoc, natDegree_mul, natDegree_mul, natDegree_mul]
  · simp only [natDegree_pow, le_add_iff_nonneg_right, zero_le]
  · exact this
  · exact greatestFactorOneSubNotDvd_ne_zero p hp
  · rw [mul_ne_zero_iff]; exact ⟨this, greatestFactorOneSubNotDvd_ne_zero p hp⟩
  · exact pow_ne_zero _ <| fun h0 => by
      let this : (1 - X : R[X]).coeff 0 = 0 := by rw [h0, coeff_zero];
      simp only [coeff_sub, coeff_one_zero, coeff_X_zero, sub_zero, one_ne_zero] at this
  · exact this
  · exact greatestFactorOneSubNotDvd_ne_zero p hp

end greatestFactorOneSubNotDvd

/--
A polynomial which makes it easier to define the Hilbert polynomial. See also the theorem
`Polynomial.preHilbert_eq_choose_sub_add`, which states that for any `d k n : ℕ` with `k ≤ n`,
`(Polynomial.preHilbert d k).eval (n : ℚ) = (n - k + d).choose d`.
-/
noncomputable def preHilbert (d k : ℕ) : ℚ[X] :=
  (d.factorial : ℚ)⁻¹ • (∏ i : Finset.range d, (X - (C (k : ℚ)) + (C (i : ℚ)) + 1))

local notation "gFOSND" => greatestFactorOneSubNotDvd

theorem preHilbert_eq_choose_sub_add (d k n : ℕ) (hkn : k ≤ n):
    (preHilbert d k).eval (n : ℚ) = (n - k + d).choose d := by
  delta preHilbert; simp only [Finset.univ_eq_attach, map_natCast, eval_smul, smul_eq_mul]
  rw [eval_prod, Finset.prod_attach _ (fun _ => eval _ (_ - _ + _ + _)), add_choose,
    cast_div (factorial_mul_factorial_dvd_factorial_add ..) (cast_ne_zero.2 <| mul_ne_zero
    (n - k).factorial_ne_zero d.factorial_ne_zero), cast_mul, div_mul_eq_div_div, div_eq_inv_mul,
    mul_eq_mul_left_iff, ← cast_div (factorial_dvd_factorial <| Nat.le_add_right (n - k) d)
    (cast_ne_zero.2 <| factorial_ne_zero (n - k)), ← ascFactorial_eq_div]
  simp_rw [eval_add, eval_sub, eval_X, eval_natCast, eval_one, ascFactorial_eq_prod_range,
    cast_prod, cast_add, cast_one, Nat.cast_sub hkn, add_assoc, add_comm, true_or]

/--
Given `p : ℤ[X]` and `d : ℕ`, the Hilbert polynomial of `p` and `d`.
See also `Polynomial.coeff_mul_invOneSubPow_eq_hilbert_eval`, which says
that `PowerSeries.coeff ℤ n (p * (@invOneSubPow ℤ _ d))` is equal to
`(Polynomial.hilbert p d).eval (n : ℚ)` for any large enough `n : ℕ`.
-/
noncomputable def hilbert (p : ℤ[X]) (d : ℕ) : ℚ[X] :=
  if h : p = 0 then 0
  else if d ≤ p.rootMultiplicity 1 then 0
  else ∑ i in Finset.range ((greatestFactorOneSubNotDvd p h).natDegree + 1),
  ((greatestFactorOneSubNotDvd p h).coeff i) * preHilbert (d - (p.rootMultiplicity 1) - 1) i

/--
Given `p : ℤ[X]` and `d : ℕ`. The key property of the Hilbert polynomial with respect to
`p` and `d`, which says that for any term of `p * (@invOneSubPow ℤ _ d)` whose degree is
large enough, its coefficient can be obtained by evaluating the Hilbert polynomial.
-/
theorem coeff_mul_invOneSubPow_eq_hilbert_eval (p : ℤ[X]) (d n : ℕ) (hn : p.natDegree < n) :
    PowerSeries.coeff ℤ n (p * (@invOneSubPow ℤ _ d)) = (hilbert p d).eval (n : ℚ) := by
  rw [hilbert]; by_cases h : p = 0
  · simp only [h, coe_zero, zero_mul, map_zero, Int.cast_zero, reduceDIte, eval_zero]
  · simp only [h, reduceDIte, zsmul_eq_mul]
    have coe_one_sub : (1 - X : ℤ[X]).toPowerSeries = 1 - (PowerSeries.X : ℤ⟦X⟧) := by
      simp only [coe_sub, coe_one, coe_X]
    by_cases h1 : d ≤ p.rootMultiplicity 1
    · simp only [h1, ↓reduceIte, eval_zero, Int.cast_eq_zero]
      rw [← pow_rootMultiplicity_mul_greatestFactorOneSubNotDvd_eq p h, mul_comm, coe_mul,
        ← mul_assoc, coe_pow, coe_one_sub, ← @Nat.sub_add_cancel (p.rootMultiplicity 1)
        d h1, mul_comm (invOneSubPow ℤ d).val, pow_add, mul_assoc ((1 - PowerSeries.X) ^
        (p.rootMultiplicity 1 - d))]
      rw [← PowerSeries.invOneSubPow_inv_eq_one_sub_pow ℤ d, Units.inv_eq_val_inv, Units.inv_mul,
        mul_one, ← coe_one_sub, ← coe_pow, ← coe_mul, coeff_coe]
      exact coeff_eq_zero_of_natDegree_lt (lt_of_le_of_lt
        (natDegree_pow_rootMultiplicity_sub_mul_greatestFactorOneSubNotDvd_le p h d h1) hn)
    · simp only [h1, ↓reduceIte]
      rw [coe_inj.2 (pow_rootMultiplicity_mul_greatestFactorOneSubNotDvd_eq p h).symm, coe_mul,
        mul_comm ((1 - X : ℤ[X]) ^ p.rootMultiplicity 1).toPowerSeries, mul_assoc,
        invOneSubPow_eq_inv_one_sub_pow, show d = p.rootMultiplicity 1 +
        (d - p.rootMultiplicity 1) by rw [Nat.add_sub_of_le <| Nat.le_of_not_ge h1], pow_add,
        Units.val_mul, ← mul_assoc ((1 - X : ℤ[X]) ^ rootMultiplicity 1 p).toPowerSeries, coe_pow,
        coe_one_sub, ← invOneSubPow_eq_inv_one_sub_pow, ← invOneSubPow_inv_eq_one_sub_pow ℤ
        (rootMultiplicity 1 p), Units.inv_eq_val_inv, Units.inv_mul, one_mul]
      simp only [inv_pow, add_tsub_cancel_left, ← inv_pow,
        ← PowerSeries.invOneSubPow_eq_inv_one_sub_pow]
      have hhh : 0 < d - rootMultiplicity 1 p := by
        simp at h1
        exact zero_lt_sub_of_lt h1
      rw [PowerSeries.invOneSubPow_val_eq_mk_sub_one_add_choose_of_pos _ _ hhh]
      rw [show (gFOSND p h).toPowerSeries = (Finset.sum (Finset.range ((gFOSND p h).natDegree + 1))
        (fun (i : ℕ) => ((gFOSND p h).coeff i) • (X ^ i)) : ℤ[X]).toPowerSeries by
        simp only [zsmul_eq_mul, coe_inj]; exact as_sum_range_C_mul_X_pow (gFOSND p h)]
      simp only [zsmul_eq_mul]; rw [eval_finset_sum]; simp only [eval_mul]
      rw [(Finset.sum_eq_sum_iff_of_le (fun i hi => by
        simp only [Subtype.forall, Finset.mem_range] at *; rw [preHilbert_eq_choose_sub_add
        (d - p.rootMultiplicity 1 - 1) i n <| Nat.le_trans (Nat.le_of_lt_succ hi) (le_trans
        (natDegree_greatestFactorOneSubNotDvd_le p h) (le_of_lt hn))])).2 <| fun i hi => by
        simp only [Subtype.forall, Finset.mem_range, mul_eq_mul_left_iff, Int.cast_eq_zero] at *;
        exact Or.intro_left _ <| preHilbert_eq_choose_sub_add (d - p.rootMultiplicity 1 - 1) i n <|
        Nat.le_trans (Nat.le_of_lt_succ hi) (le_trans (natDegree_greatestFactorOneSubNotDvd_le p h)
        (le_of_lt hn)), PowerSeries.coeff_mul]
      simp only [coeff_coe, finset_sum_coeff, coeff_intCast_mul, Int.cast_id, coeff_X_pow, mul_ite,
        mul_one, mul_zero, Finset.sum_ite_eq, Finset.mem_range, coeff_mk, ite_mul, zero_mul,
        Int.cast_sum, Int.cast_ite, Int.cast_mul, Int.cast_ofNat, Int.cast_zero]
      rw [Finset.Nat.sum_antidiagonal_eq_sum_range_succ_mk,
        show n.succ = (gFOSND p h).natDegree + 1 + (n.succ - ((gFOSND p h).natDegree + 1)) by
        simp only [Nat.succ_sub_succ_eq_sub]; rw [add_assoc, add_comm, add_assoc,
        Nat.sub_add_cancel (le_trans (natDegree_greatestFactorOneSubNotDvd_le p h) (le_of_lt hn))];
        exact n.succ_eq_one_add, Finset.sum_range_add]
      simp only [Nat.succ_sub_succ_eq_sub, add_lt_iff_neg_left, not_lt_zero', ↓reduceIte,
        Finset.sum_const_zero, add_zero]
      rw [Finset.sum_eq_sum_iff_of_le]
      · intro i hi
        simp only [Finset.mem_range] at hi
        simp only [hi, mul_eq_mul_left_iff]
        rw [add_comm]
        simp only [↓reduceIte, Int.cast_natCast, eval_intCast]
      · intro i hi
        simp only [Finset.mem_range] at hi
        simp only [hi, ↓reduceIte, Int.cast_natCast, eval_intCast]
        rw [add_comm]

end Polynomial
