/-
Copyright (c) 2024 Xavier Roblot. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Xavier Roblot
-/
import Mathlib.NumberTheory.LSeries.Deriv
import Mathlib.NumberTheory.LSeries.RiemannZeta

/-!
# L-series of counting functions

Let `F : Œ± ‚Üí ‚Ñï` be a function. Assume that there exists a positive real `l` such that
`#{x | F x ‚â§ n} / n' tends to `l`. In this file, we prove results on the L-series defined by the
function `n ‚Ü¶ Nat.card {x | F x = n}`.

## Main results.

* `NumberTheory.LSeriesSummable_card_eq`: the L-series defined by `n ‚Ü¶ Nat.card {x | F x = n}`
  is summable for `s ‚àà ‚ÑÇ` with `1 < s.re`.

* `NumberTheory.LSeries.card_eq_residue` : the L-series defined by
  `n ‚Ü¶ Nat.card {x | F x = n}` has a simple pole at `s = 1` of residue `l`.

* `NumberTheory.LSeries.abscissaOfAbsConv_card_eq `: the L-series defined by
  `n ‚Ü¶ Nat.card {x | F x = n}` has abscissa of absolute convergence `1`.
-/

open Filter Topology Complex Metric LSeries

namespace NumberTheory.LSeries.card

variable {Œ± : Type*} {F : Œ± ‚Üí ‚Ñï} {l : ‚Ñù}
  (hF : Tendsto (fun n ‚Ü¶ (Nat.card {x | F x ‚â§ n} : ‚Ñù) / n) atTop (ùìù l)) (hl : 0 < l)

section card_le

include hF hl

theorem finite_card_le (n : ‚Ñï) :
    {x | F x ‚â§ n}.Finite := by
  contrapose! hl
  have h_card : ‚àÄ ‚¶Ém‚¶Ñ, n ‚â§ m ‚Üí Nat.card {x | F x ‚â§ m} = 0 :=
    fun _ h ‚Ü¶ Set.Nat.card_coe_set_eq _ ‚ñ∏ (Set.Infinite.mono (fun _ h' ‚Ü¶ h'.trans h) hl).ncard
  suffices Tendsto (fun n ‚Ü¶ (Nat.card {x | F x ‚â§ n} : ‚Ñù) / n) atTop (ùìù 0) by
    rw [tendsto_nhds_unique hF this]
  exact tendsto_atTop_of_eventually_const fun _ h ‚Ü¶ by rw [h_card h, Nat.cast_zero, zero_div]

theorem finite_card_eq (n : ‚Ñï) :
    {x | F x = n}.Finite :=
  (finite_card_le hF hl n).subset fun _ h ‚Ü¶ h.le

theorem card_eq_succ_add_card_le (n : ‚Ñï) :
    Nat.card {x | F x = n + 1} + Nat.card {x | F x ‚â§ n} = Nat.card {x | F x ‚â§ n + 1} := by
  classical
  have : ‚àÄ n, Fintype {x | F x ‚â§ n} := fun _ ‚Ü¶ (finite_card_le hF hl _).fintype
  have : ‚àÄ n, Fintype {x | F x = n} := fun _ ‚Ü¶ (finite_card_eq hF hl _).fintype
  rw [Nat.card_eq_card_toFinset, Nat.card_eq_card_toFinset, Nat.card_eq_card_toFinset,
    ‚Üê Finset.card_union_of_disjoint]
  ¬∑ congr with x
    simpa [‚Üê Nat.lt_add_one_iff (n := n)] using le_iff_eq_or_lt.symm
  ¬∑ exact Finset.disjoint_left.mpr fun _ h ‚Ü¶ by simp_all

theorem card_le_not_bounded (N : ‚Ñï) :
    ‚àÉ n, N ‚â§ Nat.card {x | F x ‚â§ n} := by
  contrapose! hl
  refine tendsto_le_of_eventuallyLE hF (tendsto_const_div_atTop_nhds_zero_nat (N : ‚Ñù)) ?_
  filter_upwards with n using div_le_div_of_nonneg_right (Nat.cast_le.mpr (hl n).le) n.cast_nonneg

theorem mono_card_le :
    Monotone (Nat.card {x | F x ‚â§ ¬∑}) :=
  fun _ _ h‚ÇÅ ‚Ü¶ Nat.card_mono (finite_card_le hF hl _) fun _ h‚ÇÇ ‚Ü¶ h‚ÇÇ.trans h‚ÇÅ

end card_le

noncomputable section val

variable (F) in
/-- The sequence of values taken by `F` sorted by increasing order, see `card_val_eq_succ` and
`monotone_val`. -/
def val (k : ‚Ñï) : ‚Ñï := sInf {n : ‚Ñï | k ‚â§ Nat.card {x | F x ‚â§ n}}

include hl hF

theorem val_eq_succ_iff {k n : ‚Ñï} :
    val F k = n + 1 ‚Üî Nat.card {x | F x ‚â§ n} < k ‚àß k ‚â§ Nat.card {x | F x ‚â§ n + 1} := by
  rw [val, Nat.sInf_upward_closed_eq_succ_iff, Set.mem_setOf_eq, Set.mem_setOf_eq, not_le, and_comm]
  exact fun _ _ h‚ÇÅ h‚ÇÇ ‚Ü¶ h‚ÇÇ.trans (mono_card_le hF hl h‚ÇÅ)

/-- For `0 < n`, there are as many `k : ‚Ñï` such that `val k = n` than elements `x : Œ±` such
that `F x = n`.-/
theorem card_val_eq_succ (n : ‚Ñï) : Nat.card {k | val F k = n + 1} = Nat.card {x | F x = n + 1} := by
  simp_rw [val_eq_succ_iff hF hl, ‚Üê Finset.mem_Ioc, Finset.setOf_mem, Nat.card_eq_card_toFinset,
    Finset.toFinset_coe, Nat.card_Ioc, (Nat.eq_sub_of_add_eq (card_eq_succ_add_card_le hF hl n))]

theorem val_not_bounded (n : ‚Ñï) :
    ‚àÉ k, n ‚â§ val F k :=
  ‚ü®Nat.card {x | F x ‚â§ n} + 1,
    le_csInf (card_le_not_bounded hF hl _) fun _ h ‚Ü¶  ((mono_card_le hF hl).reflect_lt h).le‚ü©

theorem mono_val : Monotone (val F) :=
  fun _ _ h ‚Ü¶ le_csInf (card_le_not_bounded hF hl _)
    fun _ h' ‚Ü¶ csInf_le (OrderBot.bddBelow _) (h.trans h')

theorem tendsto_atTop_val : Tendsto (val F) atTop atTop :=
  Monotone.tendsto_atTop_atTop (mono_val hF hl) (val_not_bounded hF hl)

theorem finite_val_eq (n : ‚Ñï) :
    {k | val F k = n}.Finite := by
  rw [‚Üê compl_mem_cofinite, show {k | val F k = n} = val F ‚Åª¬π' {n} by rfl, ‚Üê Set.preimage_compl]
  exact (Nat.cofinite_eq_atTop ‚ñ∏ tendsto_atTop_val hF hl) (by simp)

/-- A consequence of `card_val_eq_succ` that is useful later on. -/
theorem card_eq_div_pow_eq_tsum_fiber (n : ‚Ñï) {s : ‚Ñù} (hs : s ‚â† 0) :
    (Nat.card {x | F x = n}) / (n : ‚Ñù) ^ s = ‚àë' (k : ‚Üë(val F ‚Åª¬π' {n})), 1 / (val F k : ‚Ñù) ^ s := by
  have : Fintype {x | val F x = n} := (finite_val_eq hF hl n).fintype
  have : Fintype {x | F x = n} := (finite_card_eq hF hl n).fintype
  rw [‚Üê Equiv.tsum_eq (Equiv.setCongr (by rfl : {k | val F k = n} = val F ‚Åª¬π' {n})), tsum_fintype,
    Finset.sum_congr rfl (fun x _ ‚Ü¶ by rw [Equiv.setCongr_apply, x.prop]), Finset.sum_const,
    Finset.card_univ, nsmul_eq_mul, mul_one_div]
  cases n with
  | zero => simp only [Nat.cast_zero, Real.zero_rpow hs, div_zero]
  | succ n => rw [‚Üê card_val_eq_succ hF hl n, ‚Üê Nat.card_eq_fintype_card]

private theorem tendsto_atTop_div_val_aux‚ÇÅ :
    ‚àÄ·∂† k in atTop, (Nat.card {x | F x ‚â§ val F k - 1} : ‚Ñù) / (val F k - 1) * (1 - 1 / val F k) ‚â§
      (k : ‚Ñù) / (val F k) := by
  filter_upwards [(tendsto_atTop.mp (tendsto_atTop_val hF hl)) 2] with k hk
  rw [one_sub_div (by positivity), ‚Üê mul_div_assoc, div_mul_cancel‚ÇÄ]
  ¬∑ refine div_le_div_of_nonneg_right (Nat.cast_le.mpr (le_of_lt ?_)) (by positivity)
    simpa only [Set.coe_setOf, Set.mem_setOf_eq, not_le] using
      Nat.not_mem_of_lt_sInf (Nat.sub_one_lt_of_lt hk)
  ¬∑ rw [sub_ne_zero, Nat.cast_ne_one]
    linarith

private theorem tendsto_atTop_div_val_aux‚ÇÇ :
  ‚àÄ·∂† k : ‚Ñï in atTop, (k : ‚Ñù) / (val F k) ‚â§
    (Nat.card {x | F x ‚â§ val F k + 1} : ‚Ñù) / (val F k + 1) * (1 + 1 / val F k) := by
  filter_upwards [(tendsto_atTop.mp (tendsto_atTop_val hF hl)) 2] with k hk
  rw [one_add_div (by positivity), ‚Üê mul_div_assoc, div_mul_cancel‚ÇÄ _ (by positivity)]
  refine div_le_div_of_nonneg_right (Nat.cast_le.mpr ?_) (Nat.cast_nonneg _)
  refine le_trans ?_ (mono_card_le hF hl (Nat.le_succ _))
  exact Nat.sInf_mem (card_le_not_bounded hF hl k)

/-- The sequence `k ‚Ü¶ k / val k` also tends to `l` at top. -/
theorem tendsto_atTop_div_val : Tendsto (fun k : ‚Ñï ‚Ü¶ (k : ‚Ñù) / (val F k)) atTop (ùìù l) := by
  have h : Tendsto (fun k ‚Ü¶ 1 / (val F k : ‚Ñù)) atTop (ùìù 0) := by
    simp_rw [one_div]
    exact Tendsto.inv_tendsto_atTop <| tendsto_natCast_atTop_iff.mpr (tendsto_atTop_val hF hl)
  refine tendsto_of_tendsto_of_tendsto_of_le_of_le' ?_ ?_
    (tendsto_atTop_div_val_aux‚ÇÅ hF hl) (tendsto_atTop_div_val_aux‚ÇÇ hF hl)
  ¬∑ rw [show ùìù l = ùìù (l * (1 - 0)) by rw [sub_zero, mul_one]]
    refine Tendsto.mul ?_ (h.const_sub 1)
    refine (hF.comp <| (tendsto_sub_atTop_nat 1).comp (tendsto_atTop_val hF hl)).congr' ?_
    filter_upwards [(tendsto_atTop.mp (tendsto_atTop_val hF hl)) 1] with k hk
    simp_rw [Function.comp_apply, Nat.cast_pred hk]
  ¬∑ rw [show ùìù l = ùìù (l * (1 + 0)) by rw [add_zero, mul_one]]
    refine Tendsto.mul ?_ (h.const_add 1)
    exact (hF.comp ((tendsto_add_atTop_nat 1).comp (tendsto_atTop_val hF hl))).congr fun _ ‚Ü¶ by simp

theorem eventually_lt_one_div_val_rpow_lt {Œµ : ‚Ñù} (hŒµ‚ÇÅ : 0 < Œµ) (hŒµ‚ÇÇ : Œµ ‚â§ l) :
    ‚àÄ·∂† k : ‚Ñï in atTop, ‚àÄ s : ‚Ñù, 0 < s ‚Üí (l - Œµ) ^ s / (k : ‚Ñù) ^ s < 1 / val F k ^ s ‚àß
      1 / val F k ^ s < (l + Œµ) ^ s / (k : ‚Ñù) ^ s := by
  rw [‚Üê sub_nonneg] at hŒµ‚ÇÇ -- To help positivity
  filter_upwards [eventually_gt_atTop 0, tendsto_nhds.mp (tendsto_atTop_div_val hF hl) Œµ hŒµ‚ÇÅ]
    with n hn h s hs
  rwa [div_lt_iff‚ÇÄ', lt_div_iff‚ÇÄ', mul_one_div, ‚Üê Real.div_rpow, Real.rpow_lt_rpow_iff,
    Real.rpow_lt_rpow_iff, ‚Üê neg_add_lt_iff_lt_add, sub_eq_add_neg, ‚Üê lt_neg_add_iff_add_lt,
    neg_add_eq_sub, ‚Üê abs_lt]
  all_goals positivity

theorem summable_one_div_val_rpow {s : ‚Ñù} (hs : 1 < s) :
    Summable (fun n ‚Ü¶ 1 / (val F n : ‚Ñù) ^ s) := by
  refine summable_of_isBigO_nat' (Real.summable_one_div_nat_rpow.mpr hs)
    (Asymptotics.isBigO_iff.mpr ‚ü®(l + l) ^ s, ?_‚ü©)
  filter_upwards [eventually_lt_one_div_val_rpow_lt hF hl hl le_rfl] with k hk
  convert (hk s (zero_lt_one.trans hs)).2.le using 1
  ¬∑ rw [Real.norm_eq_abs, _root_.abs_of_nonneg (by positivity)]
  ¬∑ rw [Real.norm_eq_abs, _root_.abs_of_nonneg (by positivity), mul_one_div]

theorem card_eq_div_pow_eq_tsum (n : ‚Ñï) {s : ‚Ñù} (hs : s ‚â† 0) :
    (Nat.card {x | F x = n}) / (n : ‚Ñù) ^ s = ‚àë' (k : ‚Üë(val F ‚Åª¬π' {n})), 1 / (val F k : ‚Ñù) ^ s := by
  have : Fintype {x | val F x = n} := (finite_val_eq hF hl n).fintype
  have : Fintype {x | F x = n} := (finite_card_eq hF hl n).fintype
  rw [‚Üê Equiv.tsum_eq (Equiv.setCongr (by rfl : {k | val F k = n} = val F ‚Åª¬π' {n})), tsum_fintype,
    Finset.sum_congr rfl (fun x _ ‚Ü¶ by rw [Equiv.setCongr_apply, x.prop]), Finset.sum_const,
    Finset.card_univ, nsmul_eq_mul, mul_one_div]
  cases n with
  | zero => simp only [Nat.cast_zero, Real.zero_rpow hs, div_zero]
  | succ n => rw [‚Üê card_val_eq_succ hF hl n, ‚Üê Nat.card_eq_fintype_card]

theorem tsum_card_eq_div_rpow_eq_tsum :
    (fun s : ‚Ñù ‚Ü¶ ‚àë' n, Nat.card {x | F x = n} / (n : ‚Ñù) ^ s) =·∂†[ùìù[>] 1]
    (fun s ‚Ü¶ ‚àë' k, 1 / (val F k : ‚Ñù) ^ s) := by
  filter_upwards [eventually_mem_nhdsWithin] with s hs
  convert HasSum.tsum_eq (HasSum.tsum_fiberwise
    (Summable.hasSum (summable_one_div_val_rpow hF hl hs)) (val F)) with n
  exact card_eq_div_pow_eq_tsum hF hl n (zero_lt_one.trans hs).ne'

end val

section tendsto

theorem tendsto_sub_mul_sum_one_div_rpow (T : Finset ‚Ñï) (v : ‚Ñï ‚Üí ‚Ñï) :
    Tendsto (fun s : ‚Ñù ‚Ü¶ (s - 1) * ‚àë n ‚àà T, 1 / (v n : ‚Ñù) ^ s) (ùìù 1) (ùìù 0) := by
  simp_rw [Finset.mul_sum, one_div, show ùìù (0 : ‚Ñù) = ùìù (‚àë n ‚àà T, 0 * 1 / (v n : ‚Ñù) ^ (1 : ‚Ñù)) by
    simp_rw [zero_mul, zero_div, Finset.sum_const, smul_zero]]
  refine tendsto_finset_sum _ fun n _ ‚Ü¶ ?_
  by_cases hv : v n = 0
  ¬∑ simp_rw [hv, Nat.cast_zero, zero_mul, zero_div]
    refine tendsto_const_nhds.congr' ?_
    filter_upwards [eventually_ne_nhds one_ne_zero] with s hs
    rw [Real.zero_rpow hs, inv_zero, mul_zero]
  ¬∑ refine Tendsto.mul ?_ ?_
    ¬∑ convert (continuous_sub_right (1 : ‚Ñù)).tendsto 1 using 2
      rw [zero_mul, sub_self]
    ¬∑ convert (Real.continuousAt_const_rpow (Nat.cast_ne_zero.mpr hv)).tendsto.inv‚ÇÄ ?_
      rwa [Real.rpow_one, Nat.cast_ne_zero]

theorem tendsto_rpow_mul_sub_mul_tsum_one_div_rpow {c : ‚Ñù} (hc : c ‚â† 0) (T : Finset ‚Ñï) :
    Tendsto (fun s ‚Ü¶ c ^ s * (s - 1) *
      ‚àë' n : ‚Üë((T : Set ‚Ñï)·∂ú), 1 / (n : ‚Ñù) ^ s) (ùìù[>] 1) (ùìù c) := by
  simp_rw [mul_assoc, show ùìù c = ùìù (c * (1 - 0)) by rw [sub_zero, mul_one]]
  refine Tendsto.mul (tendsto_nhdsWithin_of_tendsto_nhds ?_) ?_
  ¬∑ refine Continuous.tendsto' ?_ 1 c (by rw [Real.rpow_one])
    exact continuous_const.rpow continuous_id fun _ ‚Ü¶ Or.inl hc
  ¬∑ refine (tendsto_sub_mul_tsum_nat_rpow.sub (tendsto_nhdsWithin_of_tendsto_nhds
      (tendsto_sub_mul_sum_one_div_rpow T (fun n ‚Ü¶ n)))).congr' ?_
    filter_upwards [eventually_mem_nhdsWithin] with s hs
    rw [sub_eq_iff_eq_add', ‚Üê mul_add, sum_add_tsum_compl (Real.summable_one_div_nat_rpow.mpr hs)]

include hl hF

theorem exist_finset_lt_sub_mul_tsum_one_div_val_rpow_lt {Œµ : ‚Ñù} (hŒµ‚ÇÅ : 0 < Œµ) (hŒµ‚ÇÇ : Œµ ‚â§ l) :
    ‚àÉ T : Finset ‚Ñï, ‚àÄ s, 1 < s ‚Üí
      (s - 1) * ‚àë n ‚àà T, 1 / (val F n : ‚Ñù) ^ s +
        (l - Œµ) ^ s * (s - 1) * ‚àë' n : ‚Üë((T : Set ‚Ñï)·∂ú), 1 / (n : ‚Ñù) ^ s <
          (s - 1) * ‚àë' n, 1 / (val F n : ‚Ñù) ^ s ‚àß
      (s - 1) * ‚àë' n, 1/ (val F n : ‚Ñù) ^ s <
        (s - 1) * ‚àë n ‚àà T, 1 / (val F n : ‚Ñù) ^ s +
          (l + Œµ) ^ s * (s - 1) * ‚àë' n : ‚Üë((T : Set ‚Ñï)·∂ú), 1 / (n : ‚Ñù) ^ s := by
  obtain ‚ü®N, hN‚ü© := eventually_atTop.mp <| eventually_lt_one_div_val_rpow_lt hF hl hŒµ‚ÇÅ hŒµ‚ÇÇ
  refine ‚ü®Finset.range N, fun s hs ‚Ü¶ ?_‚ü©
  simp_rw [‚Üê sum_add_tsum_compl (s := Finset.range N) (summable_one_div_val_rpow hF hl hs), mul_add,
    add_lt_add_iff_left, mul_assoc, mul_left_comm _ (s- 1), mul_lt_mul_left (sub_pos.mpr hs),
    ‚Üê tsum_mul_left, mul_one_div]
  have h‚ÇÅ : ‚àÄ {S : Set ‚Ñï} {c : ‚Ñù}, Summable fun n : S ‚Ü¶ c / (n : ‚Ñù) ^ s :=
    ((Real.summable_nat_rpow_inv.mpr hs).mul_left _).subtype _
  have h‚ÇÇ : ‚àÄ {S : Set ‚Ñï}, Summable fun n : S ‚Ü¶ 1 / (val F n : ‚Ñù) ^ s :=
    (summable_one_div_val_rpow hF hl hs).subtype _
  refine ‚ü®tsum_lt_tsum (i := ‚ü®N+1, by simp‚ü©) ?_ ?_ h‚ÇÅ h‚ÇÇ,
    tsum_lt_tsum (i := ‚ü®N+1, by simp‚ü©) ?_ ?_ h‚ÇÇ h‚ÇÅ ‚ü©
  ¬∑ rintro ‚ü®i, hi‚ü©
    simp only [Finset.coe_range, Set.compl_Iio, Set.mem_Ici] at hi
    exact (hN i hi s (zero_lt_one.trans hs)).1.le
  ¬∑ exact (hN (N + 1) (Nat.le_add_right N 1) s (zero_lt_one.trans hs)).1
  ¬∑ rintro ‚ü®i, hi‚ü©
    simp only [Finset.coe_range, Set.compl_Iio, Set.mem_Ici] at hi
    exact (hN i hi s (zero_lt_one.trans hs)).2.le
  ¬∑ exact (hN (N + 1) (Nat.le_add_right N 1) s (zero_lt_one.trans hs)).2

theorem tendsto_sub_mul_tsum_one_div_val_rpow :
    Tendsto (fun s : ‚Ñù ‚Ü¶ (s - 1) * ‚àë' n, 1 / (val F n : ‚Ñù) ^ s) (ùìù[>] 1) (ùìù l) := by
  refine tendsto_nhdsWithin_nhds.mpr fun Œµ' hŒµ' ‚Ü¶ ?_
  let Œµ := min l Œµ'
  have h‚ÇÅ : 0 < Œµ := by aesop
  have h‚ÇÇ : 0 < Œµ / 3 := by positivity
  have h‚ÇÉ : Œµ / 3 < l := lt_of_lt_of_le (div_lt_self h‚ÇÅ (by norm_num)) (min_le_left l Œµ')
  have h‚ÇÑ : 0 < l - Œµ / 3 := sub_pos.mpr h‚ÇÉ
  have h‚ÇÖ : 0 < l + Œµ / 3 := by positivity
  obtain ‚ü®T, hT‚ü© := exist_finset_lt_sub_mul_tsum_one_div_val_rpow_lt hF hl h‚ÇÇ h‚ÇÉ.le
  obtain ‚ü®Œ¥‚ÇÅ, _, hŒ¥‚ÇÅ‚ü© := tendsto_nhds_nhds.mp
    (tendsto_sub_mul_sum_one_div_rpow T (val F)) (Œµ / 3) h‚ÇÇ
  obtain ‚ü®Œ¥‚ÇÇ, _, hŒ¥‚ÇÇ‚ü© := tendsto_nhdsWithin_nhds.mp
    (tendsto_rpow_mul_sub_mul_tsum_one_div_rpow h‚ÇÑ.ne' T) (Œµ / 3) h‚ÇÇ
  obtain ‚ü®Œ¥‚ÇÉ, _, hŒ¥‚ÇÉ‚ü© := tendsto_nhdsWithin_nhds.mp
    (tendsto_rpow_mul_sub_mul_tsum_one_div_rpow h‚ÇÖ.ne' T) (Œµ / 3) h‚ÇÇ
  let Œ¥ := min Œ¥‚ÇÅ (min Œ¥‚ÇÇ Œ¥‚ÇÉ)
  refine ‚ü®Œ¥, ?_, ?_‚ü©
  ¬∑ simp_all only [lt_min_iff, and_self, Set.mem_Ioi, Œ¥]
  ¬∑ intro s hs hsŒ¥
    specialize hŒ¥‚ÇÅ (lt_of_lt_of_le hsŒ¥ (by simp [Œ¥]))
    specialize hŒ¥‚ÇÇ hs (lt_of_lt_of_le hsŒ¥ (by simp [Œ¥]))
    specialize hŒ¥‚ÇÉ hs (lt_of_lt_of_le hsŒ¥ (by simp [Œ¥]))
    simp_rw [dist_eq_norm, sub_zero, Real.norm_eq_abs, abs_lt] at hŒ¥‚ÇÅ hŒ¥‚ÇÇ hŒ¥‚ÇÉ ‚ä¢
    constructor
    ¬∑ refine lt_of_le_of_lt (neg_le_neg (min_le_right l Œµ'))
        (lt_trans ?_.trans (sub_lt_sub_right (hT s hs).1 l))
      rw [‚Üê add_thirds (min l Œµ'), neg_add', sub_lt_iff_lt_add, neg_add, sub_add, add_sub_assoc]
      exact add_lt_add hŒ¥‚ÇÅ.1 hŒ¥‚ÇÇ.1
    ¬∑ refine lt_of_lt_of_le ((sub_lt_sub_right (hT s hs).2 l).trans ?_) (min_le_right l Œµ')
      rw [‚Üê add_thirds (min l Œµ'), ‚Üê sub_lt_iff_lt_add, sub_sub, add_sub_assoc]
      exact add_lt_add hŒ¥‚ÇÅ.2 hŒ¥‚ÇÉ.2

end tendsto

section main_results

open LSeries.notation

include hl hF

theorem _root_.NumberTheory.LSeriesSummable_card_eq {s : ‚ÑÇ} (hs : 1 < s.re) :
    LSeriesSummable (‚Üó(Nat.card {x | F x = ¬∑})) s := by
  have h : ‚àÄ·∂† n in atTop, (((Nat.card {x | F x = n} : ‚Ñù) / (n : ‚Ñù) ^ (s.re) : ‚Ñù) : ‚ÑÇ) =
      term (fun n ‚Ü¶ (Nat.card ‚Üë{x | F x = n})) s.re n := by
    filter_upwards [eventually_gt_atTop 0] with n hn
    rw [term_def, if_neg hn.ne', ‚Üê ofReal_natCast n, ‚Üê ofReal_cpow (by positivity), ofReal_div,
      ofReal_natCast, div_eq_mul_inv]
  refine (LSeriesSummable_iff_of_re_eq_re (by rfl : s.re = (s.re : ‚ÑÇ).re)).mpr <|
    Summable.congr_atTop ?_ h
  convert summable_ofReal.mpr ((summable_one_div_val_rpow hF hl hs).comp_injective
    (Equiv.sigmaFiberEquiv (val F)).injective).sigma with n
  exact card_eq_div_pow_eq_tsum hF hl n (by linarith)

theorem _root_.NumberTheory.LSeries.card_eq_residue :
    Tendsto (fun s : ‚Ñù ‚Ü¶ (s - 1) * L ‚Üó(Nat.card {x | F x = ¬∑}) s) (ùìù[>] 1) (ùìù l) := by
  suffices Tendsto (fun s : ‚Ñù ‚Ü¶ (s - 1) * ‚àë' n, Nat.card {x | F x = n} / (n : ‚Ñù) ^ s)
      (ùìù[>] 1) (ùìù l) by
    rw [‚Üê tendsto_ofReal_iff] at this
    refine this.congr' ?_
    filter_upwards [eventually_mem_nhdsWithin] with s hs
    change 1 < (s : ‚ÑÇ).re at hs
    simp_rw [LSeries_eq_tsum _ (ne_zero_of_one_lt_re hs), ofReal_mul, ofReal_sub, ofReal_one,
      ofReal_tsum, ofReal_div, ofReal_cpow (Nat.cast_nonneg _), ofReal_natCast]
  exact (tendsto_sub_mul_tsum_one_div_val_rpow hF hl).congr' <| EventuallyEq.rfl.mul
    (tsum_card_eq_div_rpow_eq_tsum hF hl).symm

theorem _root_.NumberTheory.LSeries.abscissaOfAbsConv_card_eq :
    LSeries.abscissaOfAbsConv ‚Üó(Nat.card {x | F x = ¬∑}) = 1 := by
  refine le_antisymm ?_ ?_
  ¬∑ exact abscissaOfAbsConv_le_of_forall_lt_LSeriesSummable' fun s hs ‚Ü¶
      LSeriesSummable_card_eq hF hl (EReal.coe_lt_coe_iff.mp hs)
  ¬∑ have h_lim := LSeries.card_eq_residue hF hl
    contrapose! hl
    suffices Tendsto (fun s : ‚Ñù ‚Ü¶ (s - 1) * LSeries (fun n ‚Ü¶ Nat.card {x | F x = n}) s)
        (ùìù[>] 1) (ùìù 0) by rw [ofReal_eq_zero.mp (tendsto_nhds_unique h_lim this)]
    rw [show ùìù 0 = ùìù (0 * (LSeries (fun n ‚Ü¶ ‚Üë(Nat.card {x | F x = n})) 1)) by rw [zero_mul]]
    refine Tendsto.mul ?_ ?_
    ¬∑ exact tendsto_sub_nhds_zero_iff.mpr continuous_ofReal.continuousWithinAt.tendsto
    ¬∑ suffices ContinuousWithinAt (fun s : ‚ÑÇ ‚Ü¶ L ‚Üó(Nat.card {x | F x = ¬∑}) s)
          {s | 1 < s.re} 1 by
        convert Tendsto.comp this.tendsto
          (continuous_ofReal.continuousWithinAt.tendsto_nhdsWithin fun _ x ‚Ü¶ x)
      refine ((AnalyticOnNhd.continuousOn (LSeries_analyticOnNhd _)).continuousWithinAt ?_).mono ?_
      ¬∑ simpa using hl
      ¬∑ intro s hs
        exact hl.trans (EReal.coe_lt_coe_iff.mpr hs)

end main_results

end NumberTheory.LSeries.card
